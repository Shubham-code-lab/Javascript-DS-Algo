const length = 5
const result = Array(length+1).fill(0).map((_, i) => i);
console.log(result); // [0, 1, 2, 3, 4, 5]

const n = 10;
const numbers = Array.from({ length: n + 1 }, (_, i) => i);
console.log(numbers); // [0, 1, 2, 3, ..., 10]



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… JavaScript Competitive Programming Cheat Sheet
// âœ… Arrays, Map, Set, Stack - Most Used Methods
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// ğŸ“¦ Array (ordered list)
const arr = [1, 2, 3];

// ğŸ” Iteration
arr.forEach(x => console.log(x));
arr.map(x => x * 2);
arr.filter(x => x % 2 === 0);
arr.reduce((a, b) => a + b, 0);

// ğŸ” Search & Check
arr.includes(2);     // true
arr.indexOf(3);      // 2
arr.find(x => x > 1); // 2
arr.every(x => x > 0); // true
arr.some(x => x > 2);  // true

// ğŸ› ï¸ Modify
arr.push(4);         // Add to end
arr.pop();           // Remove from end
arr.unshift(0);      // Add to start
arr.shift();         // Remove from start
arr.splice(1, 1);     // Remove 1 element at index 1
arr.reverse();       // Reverse in place
arr.sort((a, b) => a - b); // Numeric sort

// ğŸ“„ Convert
Array.from("abc");       // ['a', 'b', 'c']
[...new Set(arr)];       // Remove duplicates
arr.join("-");           // "1-2-3"
"1,2,3".split(",");      // ["1", "2", "3"]


// ğŸ—ºï¸ Map (key-value pairs, insertion order preserved)
const map = new Map();

// ğŸ”§ Operations
map.set("a", 1);          // Add or update
map.get("a");             // Get value
map.has("a");             // Check key
map.delete("a");          // Remove key
map.size;                 // Count of pairs
map.clear();              // Remove all

// ğŸ” Iterate
for (let [k, v] of map) console.log(k, v);
for (let k of map.keys()) console.log(k);
for (let v of map.values()) console.log(v);

// ğŸ“„ Convert
const obj = { a: 1, b: 2 };
const mapFromObj = new Map(Object.entries(obj));
const objFromMap = Object.fromEntries(map);


// ğŸ§º Set (unique values)
const set = new Set();

// ğŸ”§ Operations
set.add(1);            // Add value
set.has(1);            // Check value
set.delete(1);         // Remove value
set.size;              // Count
set.clear();           // Clear all

// ğŸ” Iterate
for (let val of set) console.log(val);
[...set].forEach(x => console.log(x));

// ğŸ“„ Convert
const arrFromSet = Array.from(set);
const setFromArr = new Set([1, 2, 2, 3]); // auto removes duplicates

// ğŸ§ª Use Case
const intersect = (a, b) => [...a].filter(x => b.has(x));
const diff = (a, b) => [...a].filter(x => !b.has(x));


// ğŸ¥ Stack (LIFO) using Array
const stack = [];

// ğŸ”§ Operations
stack.push(1);              // Add
stack.pop();                // Remove
stack[stack.length - 1];    // Peek
stack.length === 0;         // Is empty

// ğŸ”„ Custom Stack class
class Stack {
  constructor() {
    this.items = [];
  }
  push(val) { this.items.push(val); }
  pop() { return this.items.pop(); }
  peek() { return this.items[this.items.length - 1]; }
  isEmpty() { return this.items.length === 0; }
  size() { return this.items.length; }
  clear() { this.items = []; }
}

// Example usage:
// const s = new Stack();
// s.push(10); s.peek(); s.pop();


// ğŸ”¢ Create number array from 0 to n
const n = 10;
const numbers = Array.from({ length: n + 1 }, (_, i) => i);
// result: [0, 1, 2, ..., 10]









// ğŸ”„ Advanced Iteration
arr.flatMap(x => [x, x*2]); // [1, 2, 2, 4, 3, 6]
arr.findLast(x => x > 1);   // 3 (ES2023)
arr.findIndex(x => x > 1);  // 1

// ğŸ§® Math Operations
Math.max(...arr);           // 3
Math.min(...arr);           // 1
arr.reduce((a,b) => a*b);   // 6 (product)

// ğŸ—ï¸ Array Creation
Array(5).fill(0);           // [0, 0, 0, 0, 0]
[...Array(5).keys()];       // [0, 1, 2, 3, 4]

// ğŸ”€ Rearranging
arr.copyWithin(0, 1, 2);    // [2, 2, 3] (moves elements)
arr.toReversed();           // [3, 2, 1] (ES2023, non-mutating)
arr.toSorted((a,b) => b-a); // [3, 2, 1] (ES2023, non-mutating)

// ğŸ§© Chunking (useful for DP)
const chunk = (arr, size) => 
  Array.from({length: Math.ceil(arr.length/size)}, (_,i) => 
    arr.slice(i*size, i*size+size));



// ğŸ—ï¸ Initialization
const map = new Map([['a', 1], ['b', 2]]);

// ğŸ”„ Bulk Operations
const map2 = new Map([...map].map(([k,v]) => [k, v*2]));

// ğŸ§® Size Optimization
map.size; // Get actual size (O(1) unlike Object.keys(obj).length)

// ğŸ¯ Use Cases
// - Counting frequencies
const freqMap = arr.reduce((m,x) => m.set(x, (m.get(x)||0)+1), new Map());
// - Memoization
const memo = new Map();
function fib(n) {
  if(memo.has(n)) return memo.get(n);
  if(n <= 1) return n;
  memo.set(n, fib(n-1) + fib(n-2));
  return memo.get(n);
}



// ğŸ¯ Advanced Use Cases
// - Prime number check
const primes = new Set([2,3,5,7]);
function isPrime(n) { return primes.has(n); }

// - Graph algorithms
const visited = new Set();
function dfs(node) {
  if(visited.has(node)) return;
  visited.add(node);
  // ... process neighbors
}

// ğŸ”„ Set Operations
const union = new Set([...set1, ...set2]);
const intersection = new Set([...set1].filter(x => set2.has(x)));
const difference = new Set([...set1].filter(x => !set2.has(x)));






// ğŸ¥ Stack (Array-based)
stack.push(1), stack.pop(); // LIFO

// ğŸš¶ Queue (Array-based)
const queue = [];
queue.push(1);             // Enqueue
queue.shift();             // Dequeue (O(n) - inefficient)
queue[0];                  // Peek

// âš¡ Efficient Queue (using circular buffer)
class Queue {
  constructor() {
    this.items = {};
    this.front = 0;
    this.rear = 0;
  }
  enqueue(val) { this.items[this.rear++] = val; }
  dequeue() {
    const val = this.items[this.front];
    delete this.items[this.front++];
    return val;
  }
  peek() { return this.items[this.front]; }
  size() { return this.rear - this.front; }
}




// ğŸ§® Math Helpers
Math.clz32(5);            // Count leading zeros (useful for bit problems)
Number.isInteger(5.5);    // false
(5).toString(2);          // "101" (binary)
parseInt("101", 2);       // 5 (from binary)

// ğŸ² Random Numbers
Math.floor(Math.random() * 100); // 0-99
const randomInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

// ğŸ”¢ Number Generation
Array.from({length: 10}, (_, i) => i*i); // Squares [0, 1, 4, ..., 81]





const str = "hello";

// ğŸ” Search
str.includes("ell");      // true
str.startsWith("he");     // true
str.endsWith("llo");      // true
str.indexOf("l");         // 2
str.lastIndexOf("l");     // 3

// âœ‚ï¸ Slicing
str.slice(1, 4);          // "ell"
str.substring(1, 4);      // "ell"
str.substr(1, 3);         // "ell" (deprecated)

// ğŸ› ï¸ Modification
str.split("").reverse().join(""); // "olleh"
str.replace(/l/g, "L");   // "heLLo"
str.repeat(2);            // "hellohello"

// ğŸ“Š Character Codes
"a".charCodeAt(0);        // 97
String.fromCharCode(97);  // "a"






// ğŸ”¢ Sliding Window
function maxSubarray(arr, k) {
  let max = 0, sum = 0;
  for(let i=0; i<arr.length; i++) {
    sum += arr[i];
    if(i >= k-1) {
      max = Math.max(max, sum);
      sum -= arr[i-(k-1)];
    }
  }
  return max;
}

// ğŸ”„ Two Pointers
function pairSum(arr, target) {
  let left = 0, right = arr.length-1;
  while(left < right) {
    const sum = arr[left] + arr[right];
    if(sum === target) return [left, right];
    if(sum < target) left++;
    else right--;
  }
  return [-1, -1];
}

// ğŸ—ï¸ Prefix Sum
const prefixSum = arr.reduce((a,c,i) => (a.push(i>0?a[i-1]+c:c), a), []);




// ğŸš€ Faster Array Operations
// Use for/while loops instead of forEach/map when performance critical
for(let i=0; i<arr.length; i++) { /* ... */ }

// ğŸ§  Memory Optimization
// Use TypedArrays for numeric computations
const intArr = new Int32Array(1000); // Fixed-size, efficient

// âš¡ Bit Manipulation
5 & 3;   // 1 (AND)
5 | 3;   // 7 (OR)
5 ^ 3;   // 6 (XOR)
~5;      // -6 (NOT)
5 << 1;  // 10 (left shift)
5 >> 1;  // 2 (right shift)
